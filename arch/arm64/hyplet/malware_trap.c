#include <linux/module.h>
#include <linux/highmem.h>
#include <linux/hyplet.h>
#include <linux/delay.h>
#include <linux/proc_fs.h>
#include "hyp_mmu.h"
#include "hypletS.h"


struct stage2_fault_addr {
	unsigned long real_phys_addr;
	unsigned long *stg2_desc_pg;
	int stg2_desc_idx;
	int fault_mmio_to_el2;

	void *fake_vaddr;
	unsigned long fake_phys_addr;
};

static struct stage2_fault_addr faddr;

#if defined(RASPBERRY_PI3)
	#define EL2_FAULT_ADDRESS  0x3fd00000LL
#else
	#define EL2_FAULT_ADDRESS 0x1a000000LL
#endif

static long el2_fault_address(void)
{
	return EL2_FAULT_ADDRESS;
}

/*
 * Called in EL2 to handle a faulted address
 */
int __hyp_text hyplet_handle_abrt(struct hyplet_vm *vm, unsigned long addr)
{
	if (!( addr >= el2_fault_address() &&
		addr <= (el2_fault_address() + PAGE_SIZE) ) ){
			return 0;
	}

	/*
	 * An access to the virtual device detected.
	 * record the user and count
	 */
	 vm->dev_access.last_current = (long)current;
	 vm->dev_access.faulted_phys_addr = addr;
	
	 vm->dev_access.count++;
	 return 1;
}

static long make_special_page_desc(unsigned long real_phyaddr,int s2_rw)
{
	unsigned long addr = real_phyaddr;
	/*
	 * 
	 * To conceal a device, we put some page.
	*  In cases where we want to monitor access to a device.
	*  we return the same address but change the access permissions
	*/
	return (DESC_AF) | (0b11 << DESC_SHREABILITY_SHIFT) |
	                ( s2_rw  << DESC_S2AP_SHIFT) | (0b1111 << 2) |
	                  DESC_TABLE_BIT | DESC_VALID_BIT | addr;
}

void stash_descriptor(unsigned long phys_addr,unsigned long* pg ,int idx)
{
	struct page *fake_pg;

	if (phys_addr  != el2_fault_address()){
		return;
	}

	fake_pg = alloc_page(GFP_KERNEL | __GFP_ZERO);
	if (!fake_pg){
		printk("Failed to allocte fake page");
	}

	/* fake page is the page that the MMIO access */
	faddr.fake_vaddr = kmap(fake_pg);
/*
 *	Users should enter here and put the correct signature 
 *	so that a device would be instianstiated.
*/
	memset((void *)faddr.fake_vaddr,0xfe, PAGE_SIZE);
	faddr.fake_phys_addr = virt_to_phys(faddr.fake_vaddr);

	printk("hyplet: creating fake page at %lx\n",
			faddr.fake_phys_addr);
	/* the real physical address  */
	faddr.stg2_desc_pg = pg;
	faddr.stg2_desc_idx = idx;
	faddr.fault_mmio_to_el2 = 0;
	faddr.real_phys_addr  = phys_addr;
}



/* user interface  */
static struct proc_dir_entry *procfs = NULL;

static ssize_t proc_write(struct file *file, const char __user * buffer,
			  size_t count, loff_t * dummy)
{
	if (faddr.stg2_desc_idx >= 0 && faddr.real_phys_addr
				&& faddr.stg2_desc_pg != NULL) {

		if (faddr.fault_mmio_to_el2 == 1){
			faddr.fault_mmio_to_el2 = 0;
			faddr.stg2_desc_pg[faddr.stg2_desc_idx] =
						make_special_page_desc(faddr.real_phys_addr,
								S2_PAGE_ACCESS_RW);

		} else {
			faddr.fault_mmio_to_el2 = 1;
			faddr.stg2_desc_pg[faddr.stg2_desc_idx] =
					make_special_page_desc(faddr.fake_phys_addr, S2_PAGE_ACCESS_R);
			mb();
		}
		return count;
	}
	faddr.fault_mmio_to_el2 = 0;
	return count;
}

static int proc_open(struct inode *inode, struct file *filp)
{
	filp->private_data = (void *)0x01;
	return 0;
}

static ssize_t proc_read(struct file *filp, char __user * page,
			 size_t size, loff_t * off)
{
	ssize_t len = 0;
	struct hyplet_vm *vm = NULL;
	int cpu;

	if ( filp->private_data == 0)
		return 0;

	len += sprintf(page + len, "Stage2: %s %lx Descriptor %p idx=%d\n",
			faddr.fault_mmio_to_el2 == 0 ? "off" : "on",
			faddr.real_phys_addr,
			faddr.stg2_desc_pg,
			faddr.stg2_desc_idx);

	for_each_possible_cpu(cpu){
		vm = hyplet_get(cpu);
		len += sprintf(page + len, 
				"%d LastCurrent 0x%lx Addr=%lx count=%ld\n",
				cpu,
				vm->dev_access.last_current,
				vm->dev_access.faulted_phys_addr,
				vm->dev_access.count);
	}

	filp->private_data = 0x00;
	return len;
}


static struct file_operations malware_proc_ops = {
	.open = proc_open,
	.read = proc_read,
	.write = proc_write,
};


void malware_init_procfs(void)
{
	procfs =
	    proc_create_data("hyplet_stats", O_RDWR, NULL, &malware_proc_ops, NULL);
}
