#include <linux/module.h>
#include <linux/highmem.h>
#include <linux/hyplet.h>
#include <linux/delay.h>
#include <linux/proc_fs.h>
#include <linux/fs.h>		/* for file_operations */
#include <linux/slab.h>	/* versioning */
#include <linux/cdev.h>
#include "hyp_mmu.h"
#include "malware_trap.h"

static struct hyplet_driver_handler* __hyp_text is_special_address(struct hyplet_vm *vm,unsigned long addr)
{
	int i;
	struct virt_dev_access* virt = (struct virt_dev_access*)KERN_TO_HYP(vm->dev_access);
	long offset  = addr - el2_fault_address();

	for (i = 0;i < FAULT_MAX_HANDLERS; i++ ){
		if (virt->hyphnd[i].offset == offset){
			return 	&virt->hyphnd[i];
		}
	}
	return NULL;
}
/*
 * Called in EL2 to handle a faulted address
 */
int __hyp_text hyplet_handle_abrt(struct hyplet_vm *vm, unsigned long addr)
{
	struct hyplet_driver_handler* hyphnd;
	struct virt_dev_access* virt = (struct virt_dev_access*)KERN_TO_HYP(vm->dev_access);

	if (!( addr >= el2_fault_address() &&
		addr <= (el2_fault_address() + PAGE_SIZE) ) ){
			return 0;
	}
	/*
	 * An access to the virtual device detected.
	 * record the user and count
	 */
	 virt->last_current = (long)current;
	 virt->faulted_phys_addr = addr;
	 virt->count++;

/*
 *	Now we check if there is something special to do
 */
	 hyphnd  = is_special_address(vm, addr);
	 if (hyphnd){
		 	 hyphnd->action(vm, hyphnd);
	 }
	 return 1;
}


static long make_special_page_desc(unsigned long real_phyaddr,int s2_rw)
{
	unsigned long addr = real_phyaddr;
	/*
	 * 
	 * To conceal a device, we put some page.
	*  In cases where we want to monitor access to a device.
	*  we return the same address but change the access permissions
	*/
	return (DESC_AF) | (0b11 << DESC_SHREABILITY_SHIFT) |
	                ( s2_rw  << DESC_S2AP_SHIFT) | (0b1111 << 2) |
	                  DESC_TABLE_BIT | DESC_VALID_BIT | addr;
}

void stash_descriptor(unsigned long phys_addr,unsigned long* pg ,int idx)
{
	struct page *fake_pg;
	struct virt_dev_access*	 virtdev;
	struct hyplet_vm *vm;

	vm = hyplet_get_vm();

	if (phys_addr  != el2_fault_address()){
		return;
	}

	virtdev = vm->dev_access;

	fake_pg = alloc_page(GFP_KERNEL | __GFP_ZERO);
	if (!fake_pg){
		printk("Failed to allocte fake page");
	}

	/* fake page is the page that the MMIO access */
	virtdev->faddr.fake_vaddr = kmap(fake_pg);
/*
 *	Users should enter here and put the correct signature 
 *	so that a device would be instianstiated.
*/
	malware_prep_mmio((char *)virtdev->faddr.fake_vaddr);
	virtdev->faddr.fake_phys_addr = virt_to_phys(virtdev->faddr.fake_vaddr);

	printk("hyplet: creating fake page at %lx\n",
			virtdev->faddr.fake_phys_addr);

	/* the real physical address  */
	virtdev->faddr.stg2_desc_pg = pg;
	virtdev->faddr.stg2_desc_idx = idx;
	virtdev->faddr.flags = 0;
	virtdev->faddr.real_phys_addr  = phys_addr;
}



/* user interface  */
static struct proc_dir_entry *procfs = NULL;

static ssize_t proc_write(struct file *file, const char __user * buffer,
			  size_t count, loff_t * dummy)
{
	struct hyplet_vm *vm;

	vm = hyplet_get_vm();

	if (vm->dev_access->faddr.stg2_desc_idx >= 0
				&& vm->dev_access->faddr.real_phys_addr
				&& vm->dev_access->faddr.stg2_desc_pg != NULL) {

		if (vm->dev_access->faddr.flags & FAULT_MMIO_TO_EL2){
			vm->dev_access->faddr.flags &= ~FAULT_MMIO_TO_EL2;
			vm->dev_access->faddr.stg2_desc_pg[vm->dev_access->faddr.stg2_desc_idx] =
						make_special_page_desc(vm->dev_access->faddr.real_phys_addr,
								S2_PAGE_ACCESS_RW);

		} else{
			vm->dev_access->faddr.flags |= FAULT_MMIO_TO_EL2;
			vm->dev_access->faddr.stg2_desc_pg[vm->dev_access->faddr.stg2_desc_idx] =
					make_special_page_desc(vm->dev_access->faddr.fake_phys_addr,
									S2_PAGE_ACCESS_R);
			if (!(vm->dev_access->faddr.flags & FAULT_MAPPED_TO_EL2)) {
				int err;
				/* map the page to EL2  */
				unsigned long start = (unsigned long)vm->dev_access->faddr.fake_vaddr;
				err = create_hyp_mappings(
									(void *)start,
									(void *)(start + PAGE_SIZE - 1),
									PAGE_HYP);
				if (err){
					printk("hyplet: failed to map to fake page\n");
					return -1;
				}
				vm->dev_access->faddr.flags |= FAULT_MAPPED_TO_EL2;
				prepare_special_addresses(vm);
			}
			mb();
		}
		return count;
	}
	vm->dev_access->faddr.flags &= ~FAULT_MMIO_TO_EL2;
	return count;
}

static int proc_open(struct inode *inode, struct file *filp)
{
	filp->private_data = (void *)0x01;
	return 0;
}

static ssize_t proc_read(struct file *filp, char __user * page,
			 size_t size, loff_t * off)
{
	ssize_t len = 0;
	int cpu;
	struct hyplet_vm *vm = hyplet_get_vm();

	if ( filp->private_data == 0)
		return 0;

	len += sprintf(page + len, "Stage2: %s %s %lx  idx=%d\n",
			(vm->dev_access->faddr.flags &  FAULT_MMIO_TO_EL2) ? "on" : "off",
			(vm->dev_access->faddr.flags &  FAULT_MAPPED_TO_EL2) ? "EL2 mapped" : "EL2 not mapped",
				vm->dev_access->faddr.real_phys_addr,
				vm->dev_access->faddr.stg2_desc_idx);

	for_each_possible_cpu(cpu){
		vm = hyplet_get(cpu);
		len += sprintf(page + len, 
				"%d LastCurrent 0x%lx Addr=%lx count=%ld\n",
				cpu,
				vm->dev_access->last_current,
				vm->dev_access->faulted_phys_addr,
				vm->dev_access->count);
	}

	filp->private_data = 0x00;
	return len;
}


static struct file_operations malware_proc_ops = {
	.open = proc_open,
	.read = proc_read,
	.write = proc_write,
};




static ssize_t malware_ops_write(struct file *filp,
	const char __user *umem, size_t size, loff_t *off)
{
	int n;
	struct hyplet_vm *vm =  hyplet_get_vm();

	if (size > PAGE_SIZE)
		size = PAGE_SIZE;
	n = copy_from_user(vm->dev_access->faddr.fake_vaddr,umem, size);
	return size-n;
}

static ssize_t malware_ops_read(struct file *filp, char __user *umem, 
				size_t size, loff_t *off)
{
	int n;
	struct hyplet_vm *vm =  hyplet_get_vm();

	if (size > PAGE_SIZE)
		size = PAGE_SIZE;
	n = copy_to_user(umem, vm->dev_access->faddr.fake_vaddr, size);
	return size-n;
}

static struct file_operations malware_ops = {
	write: malware_ops_write,
	read:  malware_ops_read,
};

int malware_ops_major ;


void malware_init_procfs(void)
{
	procfs = proc_create_data("hyplet_stats", 
			O_RDWR, NULL, &malware_proc_ops, NULL);
	
	malware_ops_major = register_chrdev(0, "malware", &malware_ops);
	if (malware_ops_major < 0){
		printk(MODULE_NAME "Failed to create malware");
	}
}


